
# Real Talk

Let's be honest, this project is huge. Especially considering I've never done the majority of the things needed for this project. Some things I've gotten pretty decent at during development, mostly automated tests, I was already experienced with parsing and some data formatting (so text generation), but then there is compiling... The AST to Lua bytecode compiler is actually not that hard, what is hard however is the intermediate language compiler, which I need for a type system, optimizations and to make language extensions much easier to implement. I truly believe that once the intermediate language is functional the project will become actually useful, it's simply impossible to say how long that's going to take.

There are some other ideas and plans aside from a type system, optimizations and language extensions:

- Build Profiles: I've already got a functional concept implemented in `0.2.0`, however I'm not quite happy with it. The idea behind it is to have a Phobos file define all build profiles. Then these build profiles tie into a caching system allowing for fast incremental builds. I'd like for this cache system to also be exposed to the user for custom things, as well as it being shared between profiles and working with a step based system such that if you compile and disassemble the same file it won't parse it twice. I'm quite confident in my ability to do this, it'll just take time and right now intermediate language takes priority.
- Disassembling: It's already implemented, just not exposed via the command line. Waiting on build profiles for that.
- De-Compiling: Taking Lua bytecode and outputting Lua or Phobos source code would be awesome and parts of it are actually kind of necessary in order to analyze foreign code. So I really want this, but thinking about it it seems really difficult so it'll have to wait.
- Formatting: There's a basic formatter - also not exposed - which can convert AST back to source code. This means in order to format code the AST would have to be analyzed and, well, formatted. The infrastructure isn't really there for that, nor do I have much of an idea for how to do that. It's low priority.
- Refactoring: With formatting comes refactoring, however this is even further away because in order to refactor properly it would require type information. My current plan is to resolve types in the intermediate language which does not convert back to AST, it doesn't even carry all source information anymore. So my best guess would be that the IL remembers which AST nodes it "came from" and then as it resolves types it also sets types in the AST which can then be used to refactor code. It's really just a shot in the dark, no idea how it'll actually work if I get there.
- Documentation Generator: I've got some plans for an [EmmyLua](https://github.com/LuaLS/lua-language-server/wiki/Annotations) parser which then outputs HTML or pure type annotation files or both. The same output would then be used once/if Phobos gets its own type system.
- API: A proper api to use Phobos as a library. Chances are high this would come after having a docs generator, so it's also a bit further away. As covered in [Library/Reference](library_reference.md) there isn't really an api at the moment, it's just internals you can use, with the chance of breaking changes anywhere and everywhere.
- Disassembly Language: Have some kind of low level language that directly defines Lua instructions. This is really just an idea, nothing more.
- English Output: A fun little idea we had was to convert source code into the english language to assist with learning Lua. I don't think a proof of concept would be all that difficult, but making it good and useful could be tricky. Not sure, but it's pretty low priority.
- Testing Framework: What if Phobos came with a built in testing framework and assertion library? A question I've asked myself, however I've not answered it. I think it could be really nice though.
- Language Server: Another thought I had was a language server. Reading through this list of all the possible features, a lot of them could be used to make a pretty good language server. However actually doing it has a good chance of running into performance issues, so if I were to explore this idea I'd probably have to look into LuaJIT to get around 10x the normal Lua performance. The codebase is not written for LuaJIT at all though. Plus I already know from experience that feature rich language servers are big projects on their own.

And to properly cover the 4 points mentioned in the first paragraph:

- Language Extensions: Honestly this will be one of the easier parts, I'm really not worried about tokenizing and parsing. However to save myself some time I've put language extensions after IL instead of compiling from AST straight to Lua bytecode, because it will be significantly easier to generate IL from AST. In terms of which language extensions to implement, I'm not certain about a lot of them, mostly because I haven't thought about it much. I know safe chaining is a certainty, lambda expressions are likely, several expression statements like assignments, the likes of `+=` are pretty likely and I'd love better and more syntax for tuples, no idea what it would look like though. But like I said, I'm not certain, and there are definitely things not on this list that will be up for consideration.
- Intermediate Language (IL): Doesn't really matter to the user, except for library users, but it's a big step towards static code analysis and optimizations. There may end up being multiple levels of IL, depending on which information is required for different optimizations. The current WIP version of it already consists of several steps slowly expanding the data structure.
- Type System: There's 2 parts to this, the user facing side and the internal side. The first part is obviously the internal one which means a data structure to represent all possible types one can create in regular Lua, similar to TypeScript's approach which can also describe everything one can do in JavaScript. But guess what, actually representing everything that's possible to do in a dynamically typed language is difficult. I've already made several unsuccessful attempts at this, and I'm slowly feeling like it's actually doable, but still far from completion. With that data structure and utilities around it, type inference would be next, which is almost a requirement for optimizations, more on that below. And only after that comes figuring out how the programmer would type their code. For convenience the system should also read [EmmyLua](https://github.com/LuaLS/lua-language-server/wiki/Annotations) annotations, but as you can tell from the length of this description, this part is too far in the future for me to accurately predict what it will look like and do.
- Optimizations: As mentioned above, a lot of optimizations in Lua require an understanding of types, which is partially due to metatables infesting the majority of Lua's instructions/opcodes. Even a seemingly simple repeated table index cannot be optimized without knowing for certain that the indexed table doesn't have a metatable with __index, and keep in mind strings can be indexed too. Function inlining is pretty high on my list for optimizations, however they suffer from a similar issue with metatables, but worse than that is ensuring that the function is always one specific function. Most functions are stored in tables which could be referenced in lots of places, all of which could modify said tables. So basically to inline a function it has to figure out all of the references to the table and make sure none of those could ever change the function. I've only described 2 optimizations here and this is already long, so you can probably guess how much infrastructure optimizing will need and how difficult it is. It's important, but I don't know how to do it yet.

So yea, there are a lot of things that could be done in Phobos, but realistically not all of them will make it. My current goal is to make the project actually useful, which as mentioned previously comes down to getting intermediate language to work, and for usability build profiles are a must as well. Since IL compilation is turning out to be so difficult I cannot guarantee anything.
