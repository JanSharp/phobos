
local error_code_util = require("error_code_util")
local parser = require("parser")
local jump_linker = require("jump_linker")
local fold_const = require("optimize.fold_const")
local fold_control_statements = require("optimize.fold_control_statements")
local il_generator = require("il_generator")
local il_compiler = require("il_compiler")
local compiler = require("compiler")
local dump = require("dump")
local constants = require("constants")
local phobos_version = require("phobos_version")
local io_util = require("io_util")
local util = require("util")
local serialize = require("serialize")

local function get_source_name(options)
  return options.text
    and options.text_source
    or options.source_name:gsub("%?", options.filename_for_source or options.filename)
end

---@return CompileUtilContext
local function new_context()
  return {
    syntax_error_count = 0,
    files_with_syntax_error_count = 0,
  }
end

---@class CompileUtilOptions
---@field filename string
---@field filename_for_source string
---@field text string
---@field text_source string
---@field source_name string @ `?` is a placeholder for `filename`
---@field use_il_compiler boolean
---@field accept_bytecode boolean
---@field inject_scripts fun(ast:AstFunctionDef)[]
---@field error_message_count integer
---@field return_error_msg boolean @ when `false` writes the error message to io.stderr if available, or print
---@field use_load boolean
---Extra description to add when `use_load == true`.\
---Does _not_ have a `{filename}` placeholder at the moment, unlike `>= 0.1.4`.
---@field custom_header string?
---@field optimizations Optimizations

---@class CompileUtilContext
---@field syntax_error_count integer
---@field files_with_syntax_error_count integer

---@param options CompileUtilOptions
---@param context CompileUtilContext
---@return string? loadable_chunk @ bytecode or a string using `load()`. Depends on `use_load`
local function compile(options, context)
  local function check_and_print_errors(errors)
    if errors[1] then
      context.syntax_error_count = context.syntax_error_count + #errors
      context.files_with_syntax_error_count = context.files_with_syntax_error_count + 1
      local msg = error_code_util.get_message_for_list(errors, "syntax errors in "
        ..(options.text and options.text_source or options.filename), options.error_message_count
      )
      if options.return_error_msg then
        return false, msg
      end
      if io and io.stderr then
        io.stderr:write(msg)
      else
        print(msg)
      end
      return false
    end
    return true
  end

  local text = options.text or io_util.read_file(options.filename)
  if options.accept_bytecode and text:sub(1, 4) == constants.lua_signature_str then
    return text
  end
  local ast, parser_errors = parser(text, get_source_name(options))
  if not check_and_print_errors(parser_errors) then
    return nil
  end
  local jump_linker_errors = jump_linker(ast)
  if not check_and_print_errors(jump_linker_errors) then
    return nil
  end
  if options.inject_scripts then
    for _, inject_script in ipairs(options.inject_scripts) do
      inject_script(ast)
    end
  end
  if options.optimizations then
    if options.optimizations.fold_const then
      fold_const(ast)
    end
    if options.optimizations.fold_control_statements then
      fold_control_statements(ast)
    end
  end
  local compiled
  if options.use_il_compiler then
    local il = il_generator(ast)
    compiled = il_compiler(il)
  else
    compiled = compiler(ast, options)
  end
  local bytecode = dump(compiled)
  if options.use_load then
    local custom_header = ""
    if options.custom_header then
      -- in reality this should never actually receive a string containing `\r` thanks to Lua's string
      -- normalization. However since this will be user input, well, anything is possible. I just need it not
      -- to generate invalid files, so `\r` simply gets deleted
      custom_header = "\n\z
        ----------------------------------------------------------------\n\z
        -- "..options.custom_header:gsub("\r", ""):gsub("\n", "\n-- ").."\z
      "
    end
    return "\z
      ----------------------------------------------------------------\n\z
      -- This file was generated by Phobos version "..util.format_version(phobos_version)..custom_header.."\n\z
      ----------------------------------------------------------------\n\z
      local main_chunk=assert(load(\""..util.to_binary_string(bytecode, true).."\",nil,'b'))\n\z
      return main_chunk(...)\z
    "
  else
    if options.custom_header then
      util.debug_abort("A custom_header can only be used when 'use_load == true'.")
    end
    return bytecode
  end
end

return {
  new_context = new_context,
  get_source_name = get_source_name,
  compile = compile,
}
