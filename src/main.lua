
---@type LFS
local lfs = require("lfs")
local Path = require("lib.LuaPath.path")
local arg_parser = require("lib.LuaArgParser.arg_parser")
arg_parser.register_type(Path.arg_parser_path_type_def)

local args_config = {
  options = {
    {
      field = "source_path",
      long = "source",
      short = "s",
      description = "Source directory path.",
      single_param = true,
      type = "path",
    },
    {
      field = "temp_path",
      long = "temp",
      short = "t",
      description = "Directory path to put temporary files in. Relative to source dir.",
      single_param = true,
      type = "path",
      default_value = Path.new("pho-temp"),
    },
    {
      field = "output_path",
      long = "output",
      short = "o",
      description = "Target directory path to put generated files into. Relative to source dir. \z
        Leave this out to generate output next to source files.",
      single_param = true,
      type = "path",
      optional = true,
    },
    {
      field = "ignore_paths",
      long = "ignore",
      short = "i",
      description = "Paths to ignore (files and or directories). Relative to source dir.",
      min_params = 0,
      type = "path",
      optional = true,
    },
    {
      field = "use_load",
      long = "use-load",
      description = "Use `load()` to load the bytecode in the generated \z
        files instead of generating raw bytecode files",
      flag = true,
    },
    {
      field = "pho_extension",
      long = "pho-extension",
      description = "The file extension of phobos files.",
      single_param = true,
      type = "string",
      default_value = ".pho",
    },
    {
      field = "lua_extension",
      long = "lua-extension",
      description = "The file extension of lua files.",
      single_param = true,
      type = "string",
      default_value = ".lua",
    },
    {
      field = "source_name",
      long = "source-name",
      description = "A 'pattern' to use for the 'source' name of the generated bytecode.\n\z
        `?` is a placeholder for the relative file name (with `/` as separators and including the extension).",
      single_param = true,
      type = "string",
      default_value = "@?",
    },
    {
      field = "ignore_syntax_errors",
      long = "ignore-syntax-errors",
      description = "Continue and ignore a file after encountering a syntax error and print it to std out.",
      flag = true,
    },
    {
      field = "hide_syntax_error_messages",
      long = "hide-syntax-error-messages",
      description = "Used if `--ignore-syntax-errors` is set stops printing error messages to std out.",
      flag = true,
    },
    {
      field = "verbose",
      long = "verbose",
      short = "v",
      description = "Print more information to std out.",
      flag = true,
    },
    {
      field = "monitor_memory_allocation",
      long = "monitor-memory",
      description = "Monitors total memory allocated during the entire compilation \z
        process at the cost of ~10% longer compilation times.\n\z
        (Stops incremental GC. Instead runs full garbage collection whenever it \z
        exceeds 4GB current memory usage. May overshoot by quite a bit.)",
      flag = true,
    },
  },
  positional = {},
}

local args
do
  local err
  args, err = arg_parser.parse({...}, args_config)
  if (not args) or args.help then
    if not args then
      print(err)
      print()
    end
    print(arg_parser.get_help_string(args_config))
    return
  end
end

if args.monitor_memory_allocation then
  collectgarbage("stop")
end

local function exists_and_is_dir(path)
  if path:attr("mode") ~= "directory" then
    error("The given path '"..path:str().." does not exist.")
  end
end

exists_and_is_dir(args.source_path)
local clean_up_output_dir = true
if args.output_path then
  clean_up_output_dir = false
elseif args.pho_extension == args.lua_extension then
  error("When generating output next to source files the \z
    lua and phobos file extensions cannot be equal.")
end

-- if there is no target directory the output will be generated in place
-- in this case there is no auto cleanup of output files

-- if there is a target directory it will automatically delete any
-- lua_extension files it did not just generate at the end of compilation
-- (maybe add a flag to disable this but that should be hardly needed)

---relative
local source_file_paths = {}
---relative
local dir_paths = {}

---relative
local filename_lut = {}

local ignore_paths = {
  [args.temp_path:str()] = true,
}
if args.output_path then
  ignore_paths[args.output_path:str()] = true
end

for _, ignore_dir_path in ipairs(args.ignore_paths) do
  ignore_paths[ignore_dir_path:str()] = true
end

-- search for source files

local visited_file_count = 0

local function search_dir(dir, relative_dir)
  relative_dir = relative_dir or Path.new()
  if ignore_paths[relative_dir:str()] then
    return
  end
  dir_paths[#dir_paths+1] = relative_dir

  for entry in lfs.dir(dir:str()) do
    if entry == "." or entry == ".." then
      goto continue
    end

    local entry_path = dir / entry
    local mode = entry_path:attr("mode")
    if mode == "directory" then
      search_dir(entry_path, relative_dir / entry)
    elseif mode == "file" then
      visited_file_count = visited_file_count + 1
      if (not ignore_paths[(relative_dir / entry):str()])
        and entry_path:extension() == args.pho_extension
      then
        source_file_paths[#source_file_paths+1] = relative_dir / entry
        filename_lut[(relative_dir / entry_path:filename()):str()] = true
      end
    end

    ::continue::
  end
end

search_dir(args.source_path)

if args.verbose then
  print("visited "..visited_file_count.." files in source dir")
end

-- delete files from output

visited_file_count = 0

local output_path = Path.combine(args.source_path, args.output_path)

-- TODO: also look into dirs not found in source [...]
-- and delete those if they end up being empty
-- after deleting lua files

if args.output_path then
  for _, relative_dir_path in ipairs(dir_paths) do
    local output_dir_path = output_path / relative_dir_path
    if output_dir_path:exists() then
      for entry in lfs.dir(output_dir_path:str()) do
        if entry == "." or entry == ".." then
          goto continue
        end

        local entry_path = output_dir_path / entry
        if entry_path:attr("mode") == "file" then
          visited_file_count = visited_file_count + 1
          if not filename_lut[(relative_dir_path / entry_path:filename()):str()] then
            if args.verbose then
              print("Deleting '"..entry_path:str().."'.")
            end
            os.remove(entry_path:str())
          end
        end

        ::continue::
      end
    end
  end
end

if args.verbose then
  print("visited "..visited_file_count.." files in output dir")
end

-- compile

local parser = require("parser")
local jump_linker = require("jump_linker")
local fold_const = require("optimize.fold_const")
local compiler = require("compiler")
local dump = require("dump")

local err_count = 0
local start_time = os.clock()
if args.verbose then
  print("started compilation of "..(#source_file_paths).." files at ~ "..start_time.."s")
end

local total_memory_allocated = 0
local compiled_file_count = 0

for _, source_file_path in ipairs(source_file_paths) do
  if args.monitor_memory_allocation then
    compiled_file_count = compiled_file_count + 1
    if (compiled_file_count % 8) == 0 then
      local c = collectgarbage("count")
      if c > 4 * 1000 * 1000 then
        collectgarbage("collect")
        total_memory_allocated = total_memory_allocated + (c - collectgarbage("count"))
      end
    end
  end

  local file = assert(io.open((args.source_path / source_file_path):str(), "r"))
  local text = file:read("*a")
  file:close()

  local source_name = args.source_name:gsub("%?", source_file_path:str())
  local ast
  if args.ignore_syntax_errors then
    local success
    success, ast = pcall(parser, text, source_name)
    if not success then
      err_count = err_count + 1
      if not args.hide_syntax_error_messages then
        print(ast:gsub("^[^:]+:%d+: ", "").." in "..source_name)
      end
      goto continue
    end
  else
    ast = parser(text, source_name)
  end
  jump_linker(ast)
  fold_const(ast)
  local compiled = compiler(ast)
  local bytecode = dump(compiled)
  local output
  if args.use_load then
    output = string.format("local main_chunk=assert(load(%q,nil,'b'))\nreturn main_chunk(...)", bytecode)
  else
    output = bytecode
  end

  local output_file_path = output_path / source_file_path
  local dir = output_file_path:sub(1, -2)
  output_file_path = dir / (output_file_path:filename()..args.lua_extension)
  if not dir:exists() then
    -- i thought for sure you could just mkdir multiple dir levels at once... but i guess not?
    for i = 1, #dir do
      if not dir:sub(1, i):exists() then
        -- this might fail, for example for drive letters,
        -- but that doesn't matter, as long as the output file
        -- can get created (=> asserted)
        lfs.mkdir(dir:sub(1, i):str())
      end
    end
  end

  file = assert(io.open(output_file_path:str(), args.use_load and "w" or "wb"))
  file:write(output)
  file:close()
  ::continue::
end

if args.verbose and args.ignore_syntax_errors then
  print(err_count.." files with syntax errors")
end

if args.monitor_memory_allocation then
  total_memory_allocated = total_memory_allocated + collectgarbage("count")
  print("total memory allocated "..(total_memory_allocated / (1000 * 1000)).." G-bytes")
end

local end_time = os.clock()
if args.verbose then
  print("compilation took ~ "..(end_time - start_time).."s")
end
print("total time elapsed ~ "..end_time.."s")
